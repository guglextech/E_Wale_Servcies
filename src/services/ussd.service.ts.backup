import { Injectable } from "@nestjs/common";
import { InjectModel } from "@nestjs/mongoose";
import { Model } from "mongoose";
import { FinalUssdReq } from "src/models/dto/hubtel/callback-ussd.dto";
import { HbEnums } from "src/models/dto/hubtel/hb-enums";
import { HBussdReq, CheckOutItem } from "src/models/dto/hubtel/hb-ussd.dto";
import axios from "axios";
import { HbPayments } from "../models/dto/hubtel/callback-ussd.schema";
import { Voucher } from "../models/schemas/voucher.schema";
import { User } from "../models/schemas/user.shema";
import { UssdLog } from "../models/schemas/ussd-log.schema";
import { sendVoucherSms } from "../utils/sendSMS";
import { Transactions } from "../models/schemas/transaction.schema";
import { VouchersService } from "./vouchers.service";
import { AirtimeService } from "./airtime.service";
import { BundleService } from "./bundle.service";
import { TVBillsService } from "./tv-bills.service";
import { UtilityService } from "./utility.service";
import { NetworkProvider, BundleType } from "../models/dto/airtime.dto";
import { BundleOption } from "../models/dto/bundle.dto";
import { TVProvider, TVAccountInfo } from "../models/dto/tv-bills.dto";
import { UtilityProvider, UtilityMeterInfo } from "../models/dto/utility.dto";
import { TransactionStatusService } from "./transaction-status.service";
import { CommissionService } from "./commission.service";

interface SessionState {
  service?: string;
  serviceType?: string; // 'result_checker', 'data_bundle', 'voice_bundle', 'airtime_topup', 'pay_bills', 'utility_service'
  mobile?: string;
  name?: string;
  quantity?: number;
  flow?: "self" | "other";
  totalAmount?: number;
  assignedVoucherCodes?: string[];
  network?: NetworkProvider;
  bundleType?: BundleType;
  amount?: number;
  // Bundle specific fields
  bundles?: BundleOption[];
  currentBundlePage?: number;
  selectedBundle?: BundleOption;
  bundleValue?: string;
  // TV Bills specific fields
  tvProvider?: TVProvider;
  accountNumber?: string;
  accountInfo?: TVAccountInfo[];
  // Utility specific fields
  utilityProvider?: UtilityProvider;
  meterNumber?: string;
  meterInfo?: UtilityMeterInfo[];
  email?: string;
  sessionId?: string;
}

@Injectable()
export class UssdService {
  private sessionMap = new Map<string, SessionState>();

  constructor(
    @InjectModel(HbPayments.name) private readonly hbPaymentsModel: Model<HbPayments>,
    @InjectModel(Transactions.name) private readonly transactionModel: Model<Transactions>,
    @InjectModel(Voucher.name) private readonly voucherModel: Model<Voucher>,
    @InjectModel(User.name) private readonly userModel: Model<User>,
    @InjectModel(UssdLog.name) private readonly ussdLogModel: Model<UssdLog>,
    private readonly vouchersService: VouchersService,
    private readonly airtimeService: AirtimeService,
    private readonly bundleService: BundleService,
    private readonly tvBillsService: TVBillsService,
    private readonly utilityService: UtilityService,
    private readonly transactionStatusService: TransactionStatusService,
    private readonly commissionService: CommissionService,
  ) { }

  async handleUssdRequest(req: HBussdReq) {
    try {
      switch (req.Type.toLowerCase()) {
        case HbEnums.INITIATION:
          return this.handleInitiation(req);
        case HbEnums.RESPONSE:
          return this.handleResponse(req);
        case HbEnums.ADDTOCART:
        default:
          return this.releaseSession(req.SessionId);
      }
    } catch (error) {
      console.error(error);
      // Log error and mark session as failed
      await this.updateUssdLog(req.SessionId, 'failed', {
        errorMessage: error.message || 'Unknown error occurred'
      });
      return this.releaseSession(req.SessionId);
    }
  }

  private async handleInitiation(req: HBussdReq) {
    this.sessionMap.set(req.SessionId, {});

    // Log the initial USSD dial
    await this.logUssdInteraction(req, {}, 'initiated');

    return this.createResponse(
      req.SessionId,
      "Welcome to E-Wale",
      `Welcome to E-Wale\n1. Results Voucher\n2. Data Bundle\n3. Airtime Top-Up\n4. Pay Bills\n5. Utility Service \n0. Contact us`,
      HbEnums.DATATYPE_INPUT,
      HbEnums.FIELDTYPE_NUMBER,
      HbEnums.RESPONSE
    );
  }

  private async handleResponse(req: HBussdReq) {
    let state = this.sessionMap.get(req.SessionId);
    if (!state) {
      return this.createResponse(
        req.SessionId,
        "Error",
        "Session expired or invalid. Please restart.",
        HbEnums.DATATYPE_DISPLAY,
        HbEnums.FIELDTYPE_TEXT,
        HbEnums.RELEASE
      );
    }


    switch (req.Sequence) {
      case 2:
        return await this.handleMainMenuSelection(req, state);
      case 3:
        return this.handleServiceTypeSelection(req, state);
      case 4:
        return this.handleStep4(req, state);
      case 5:
        return this.handleStep5(req, state);
      case 6:
        return this.handleStep6(req, state);
      case 7:
        return this.handleStep7(req, state);
      case 8:
        return this.handleStep8(req, state);
      case 9:
        return this.handleStep9(req, state);
      case 10:
        return this.handlePaymentConfirmation(req, state);
      default:
        return this.releaseSession(req.SessionId);
    }
  }

  private async handleMainMenuSelection(req: HBussdReq, state: SessionState) {
    if (req.Message === "0") {
      return this.createResponse(
        req.SessionId,
        "Contact Us",
        "Phone: +233262195121\nEmail: guglextechnologies@gmail.com",
        HbEnums.DATATYPE_DISPLAY,
        HbEnums.FIELDTYPE_TEXT,
        HbEnums.RELEASE
      );
    }

    if (req.Message === "1") {
      state.serviceType = "result_checker";
      this.sessionMap.set(req.SessionId, state);
      
      // Log service selection
      await this.logUssdInteraction(req, state, 'service_selected');
      
      return this.createResponse(
        req.SessionId,
        "Result E-Checkers",
        "Select Result Checker:\n1. BECE \n2. WASSCE/NovDec \n3. School Placement Checker",
        HbEnums.DATATYPE_INPUT,
        HbEnums.FIELDTYPE_NUMBER,
        HbEnums.RESPONSE
      );
    }

    if (req.Message === "2") {
      state.serviceType = "data_bundle";
      this.sessionMap.set(req.SessionId, state);
      
      // Log service selection
      await this.logUssdInteraction(req, state, 'service_selected');
      
      return this.createResponse(
        req.SessionId,
        "Select Network",
        "Select Network:\n1. MTN\n2. Telecel Ghana\n3. AT",
        HbEnums.DATATYPE_INPUT,
        HbEnums.FIELDTYPE_NUMBER,
        HbEnums.RESPONSE
      );
    }

    if (req.Message === "3") {
      state.serviceType = "airtime_topup";
      this.sessionMap.set(req.SessionId, state);
      
      // Log service selection
      await this.logUssdInteraction(req, state, 'service_selected');
      
      return this.createResponse(
        req.SessionId,
        "Select Network",
        "Select Network:\n1. MTN\n2. Telecel Ghana\n3. AT",
        HbEnums.DATATYPE_INPUT,
        HbEnums.FIELDTYPE_NUMBER,
        HbEnums.RESPONSE
      );
    }

    if (req.Message === "4") {
      state.serviceType = "pay_bills";
      this.sessionMap.set(req.SessionId, state);
      
      // Log service selection
      await this.logUssdInteraction(req, state, 'service_selected');
      
      return this.createResponse(
        req.SessionId,
        "Select TV Provider",
        "Select TV Provider:\n1. DSTV\n2. GoTV\n3. StarTimes TV",
        HbEnums.DATATYPE_INPUT,
        HbEnums.FIELDTYPE_NUMBER,
        HbEnums.RESPONSE
      );
    }

    if (req.Message === "5") {
      state.serviceType = "utility_service";
      this.sessionMap.set(req.SessionId, state);
      
      // Log service selection
      await this.logUssdInteraction(req, state, 'service_selected');
      
      return this.createResponse(
        req.SessionId,
        "Select Utility Service",
        "Select Utility Service:\n1. ECG Prepaid\n2. Ghana Water",
        HbEnums.DATATYPE_INPUT,
        HbEnums.FIELDTYPE_NUMBER,
        HbEnums.RESPONSE
      );
    }

    // Handle other menu options (coming soon)
    if (["6"].includes(req.Message)) {
      const serviceNames = {
        "6": "Other Services"
      };

      return this.createResponse(
        req.SessionId,
        "Coming Soon",
        `${serviceNames[req.Message]} are coming soon. Please select an available service.`,
        HbEnums.DATATYPE_DISPLAY,
        HbEnums.FIELDTYPE_TEXT,
        HbEnums.RELEASE
      );
    }

    return this.createResponse(
      req.SessionId,
      "Invalid Selection",
      "Please select a valid option (1-5 or 0)",
      HbEnums.DATATYPE_INPUT,
      HbEnums.FIELDTYPE_NUMBER,
      HbEnums.RESPONSE
    );
  }

  private handleServiceTypeSelection(req: HBussdReq, state: SessionState) {
    if (state.serviceType === "result_checker") {
      if (!["1", "2", "3"].includes(req.Message)) {
        return this.createResponse(
          req.SessionId,
          "Invalid Selection",
          "Please select 1, 2, or 3",
          HbEnums.DATATYPE_INPUT,
          HbEnums.FIELDTYPE_NUMBER,
          HbEnums.RESPONSE
        );
      }

      // Map service selection to service name
      const serviceMap = {
        "1": "BECE Checker Voucher",
        "2": "NovDec Checker",
        "3": "School Placement Checker"
      };

      state.service = serviceMap[req.Message];
      this.sessionMap.set(req.SessionId, state);

      return this.createResponse(
        req.SessionId,
        "Buying For",
        "Buy for:\n1. Buy for me\n2. For other",
        HbEnums.DATATYPE_INPUT,
        HbEnums.FIELDTYPE_NUMBER,
        HbEnums.RESPONSE
      );
    }

    if (state.serviceType === "data_bundle") {
      if (!["1", "2", "3"].includes(req.Message)) {
        return this.createResponse(
          req.SessionId,
          "Invalid Selection",
          "Please select 1, 2, or 3",
          HbEnums.DATATYPE_INPUT,
          HbEnums.FIELDTYPE_NUMBER,
          HbEnums.RESPONSE
        );
      }

      const networkMap = {
        "1": NetworkProvider.MTN,
        "2": NetworkProvider.TELECEL,
        "3": NetworkProvider.AT
      };

      state.network = networkMap[req.Message];
      this.sessionMap.set(req.SessionId, state);

      // Show available bundles for the selected network
      return this.showNetworkBundles(req.SessionId, state);
    }

    if (state.serviceType === "airtime_topup") {
      if (!["1", "2", "3"].includes(req.Message)) {
        return this.createResponse(
          req.SessionId,
          "Invalid Selection",
          "Please select 1, 2, or 3",
          HbEnums.DATATYPE_INPUT,
          HbEnums.FIELDTYPE_NUMBER,
          HbEnums.RESPONSE
        );
      }

      const networkMap = {
        "1": NetworkProvider.MTN,
        "2": NetworkProvider.TELECEL,
        "3": NetworkProvider.AT
      };

      state.network = networkMap[req.Message];
      this.sessionMap.set(req.SessionId, state);

      return this.createResponse(
        req.SessionId,
        "Enter Mobile Number",
        "Enter mobile number to purchase airtime (e.g., 0550982043):",
        HbEnums.DATATYPE_INPUT,
        HbEnums.FIELDTYPE_PHONE,
        HbEnums.RESPONSE
      );
    }

    if (state.serviceType === "utility_service") {
      if (!["1", "2"].includes(req.Message)) {
        return this.createResponse(
          req.SessionId,
          "Invalid Selection",
          "Please select 1 or 2",
          HbEnums.DATATYPE_INPUT,
          HbEnums.FIELDTYPE_NUMBER,
          HbEnums.RESPONSE
        );
      }

      const utilityProviderMap = {
        "1": UtilityProvider.ECG,
        "2": UtilityProvider.GHANA_WATER
      };

      state.utilityProvider = utilityProviderMap[req.Message];
      this.sessionMap.set(req.SessionId, state);

      if (state.utilityProvider === UtilityProvider.ECG) {
        return this.createResponse(
          req.SessionId,
          "Enter Mobile Number",
          "Enter mobile number linked to ECG meter (e.g., 0550982034):",
          HbEnums.DATATYPE_INPUT,
          HbEnums.FIELDTYPE_PHONE,
          HbEnums.RESPONSE
        );
      } else {
        return this.createResponse(
          req.SessionId,
          "Enter Meter Number",
          "Enter Ghana Water meter number:",
          HbEnums.DATATYPE_INPUT,
          HbEnums.FIELDTYPE_TEXT,
          HbEnums.RESPONSE
        );
      }
    }

    if (state.serviceType === "pay_bills") {
      if (!["1", "2", "3"].includes(req.Message)) {
        return this.createResponse(
          req.SessionId,
          "Invalid Selection",
          "Please select 1, 2, or 3",
          HbEnums.DATATYPE_INPUT,
          HbEnums.FIELDTYPE_NUMBER,
          HbEnums.RESPONSE
        );
      }

      const tvProviderMap = {
        "1": TVProvider.DSTV,
        "2": TVProvider.GOTV,
        "3": TVProvider.STARTIMES
      };

      state.tvProvider = tvProviderMap[req.Message];
      this.sessionMap.set(req.SessionId, state);

      return this.createResponse(
        req.SessionId,
        "Enter Account Number",
        "Enter TV account number:",
        HbEnums.DATATYPE_INPUT,
        HbEnums.FIELDTYPE_TEXT,
        HbEnums.RESPONSE
      );
    }

    return this.createResponse(
      req.SessionId,
      "Invalid Service",
      "Invalid service type selected",
      HbEnums.DATATYPE_DISPLAY,
      HbEnums.FIELDTYPE_TEXT,
      HbEnums.RELEASE
    );
  }

  private async handleStep4(req: HBussdReq, state: SessionState) {
    if (state.serviceType === "result_checker") {
      return this.handleBuyerType(req, state);
    } else if (state.serviceType === "data_bundle") {
      return this.handleBundleSelection(req, state);
    } else if (state.serviceType === "airtime_topup") {
      return this.handleAirtimeMobileNumber(req, state);
    } else if (state.serviceType === "pay_bills") {
      return this.handleTVAccountQuery(req, state);
    } else if (state.serviceType === "utility_service") {
      return this.handleUtilityQuery(req, state);
    }
  }

  private handleStep5(req: HBussdReq, state: SessionState) {
    if (state.serviceType === "result_checker") {
      if (state.flow === "self") {
        return this.handleQuantityInput(req, state);
      } else {
        return this.handleMobileNumber(req, state);
      }
    } else if (state.serviceType === "data_bundle") {
      return this.handleBundleMobileNumber(req, state);
    } else if (state.serviceType === "airtime_topup") {
      return this.handleAmountInput(req, state);
    } else if (state.serviceType === "pay_bills") {
      return this.handleTVAmountInput(req, state);
    } else if (state.serviceType === "utility_service") {
      return this.handleUtilityStep5(req, state);
    }
  }

  private handleStep6(req: HBussdReq, state: SessionState) {
    if (state.serviceType === "result_checker") {
      if (state.flow === "self") {
        return this.handleOrderDetails(req, state);
      } else {
        return this.handleNameInput(req, state);
      }
    } else if (state.serviceType === "data_bundle") {
      return this.handleOrderDetails(req, state);
    } else if (state.serviceType === "airtime_topup") {
      return this.handleOrderDetails(req, state);
    } else if (state.serviceType === "pay_bills") {
      return this.handleOrderDetails(req, state);
    } else if (state.serviceType === "utility_service") {
      return this.handleUtilityAmountInput(req, state);
    }
  }

  private handleStep7(req: HBussdReq, state: SessionState) {
    if (state.serviceType === "result_checker") {
      if (state.flow === "other") {
        return this.handleQuantityInput(req, state);
      } else {
        return this.releaseSession(req.SessionId);
      }
    } else if (state.serviceType === "data_bundle") {
      return this.releaseSession(req.SessionId);
    } else if (state.serviceType === "airtime_topup") {
      return this.releaseSession(req.SessionId);
    } else if (state.serviceType === "pay_bills") {
      return this.releaseSession(req.SessionId);
    } else if (state.serviceType === "utility_service") {
      return this.handleOrderDetails(req, state);
    }
  }

  private handleStep8(req: HBussdReq, state: SessionState) {
    if (state.serviceType === "result_checker") {
      if (state.flow === "other") {
        return this.handleOrderDetails(req, state);
      } else {
        return this.releaseSession(req.SessionId);
      }
    } else if (state.serviceType === "data_bundle") {
      return this.releaseSession(req.SessionId);
    } else if (state.serviceType === "airtime_topup") {
      return this.releaseSession(req.SessionId);
    } else if (state.serviceType === "pay_bills") {
      return this.releaseSession(req.SessionId);
    } else if (state.serviceType === "utility_service") {
      return this.releaseSession(req.SessionId);
    }
  }

  private handleStep9(req: HBussdReq, state: SessionState) {
    if (state.serviceType === "result_checker") {
      return this.handlePaymentConfirmation(req, state);
    } else if (state.serviceType === "data_bundle") {
      return this.handlePaymentConfirmation(req, state);
    } else if (state.serviceType === "airtime_topup") {
      return this.releaseSession(req.SessionId);
    } else if (state.serviceType === "pay_bills") {
      return this.handlePaymentConfirmation(req, state);
    } else if (state.serviceType === "utility_service") {
      return this.handlePaymentConfirmation(req, state);
    }
  }

  private handleBuyerType(req: HBussdReq, state: SessionState) {
    if (req.Message === "1") {
      state.flow = "self";
      this.sessionMap.set(req.SessionId, state);
      return this.createResponse(
        req.SessionId,
        "Enter Quantity",
        "How many vouchers do you want to buy?",
        HbEnums.DATATYPE_INPUT,
        HbEnums.FIELDTYPE_NUMBER,
        HbEnums.RESPONSE
      );
    } else if (req.Message === "2") {
      state.flow = "other";
      this.sessionMap.set(req.SessionId, state);
      return this.createResponse(
        req.SessionId,
        "Enter Mobile Number",
        "Enter other mobile number (e.g., 0550982034):",
        HbEnums.DATATYPE_INPUT,
        HbEnums.FIELDTYPE_PHONE,
        HbEnums.RESPONSE
      );
    } else {
      return this.createResponse(
        req.SessionId,
        "Invalid Selection",
        "Please select 1 or 2",
        HbEnums.DATATYPE_INPUT,
        HbEnums.FIELDTYPE_NUMBER,
        HbEnums.RESPONSE
      );
    }
  }

  private async handleTVAccountQuery(req: HBussdReq, state: SessionState) {
    try {
      // Validate account number format
      if (!this.tvBillsService.validateAccountNumber(req.Message, state.tvProvider)) {
        return this.createResponse(
          req.SessionId,
          "Invalid Account Number",
          "Please enter a valid account number:",
          HbEnums.DATATYPE_INPUT,
          HbEnums.FIELDTYPE_TEXT,
          HbEnums.RESPONSE
        );
      }

      // Query account from Hubtel
      const accountResponse = await this.tvBillsService.queryAccount({
        accountNumber: req.Message,
        provider: state.tvProvider
      });

      if (accountResponse.ResponseCode !== '0000') {
        return this.createResponse(
          req.SessionId,
          "Error",
          `Failed to fetch account: ${accountResponse.Message}`,
          HbEnums.DATATYPE_DISPLAY,
          HbEnums.FIELDTYPE_TEXT,
          HbEnums.RELEASE
        );
      }

      // Store account info and number in session
      state.accountInfo = accountResponse.Data;
      state.accountNumber = req.Message;
      this.sessionMap.set(req.SessionId, state);

      // Display account information
      const accountDisplay = this.tvBillsService.formatAccountInfo(accountResponse.Data);

      return this.createResponse(
        req.SessionId,
        "Account Information",
        `${accountDisplay}\n\nEnter payment amount:`,
        HbEnums.DATATYPE_INPUT,
        HbEnums.FIELDTYPE_DECIMAL,
        HbEnums.RESPONSE
      );
    } catch (error) {
      console.error('Error querying TV account:', error);
      return this.createResponse(
        req.SessionId,
        "Error",
        "Failed to fetch account information. Please try again.",
        HbEnums.DATATYPE_DISPLAY,
        HbEnums.FIELDTYPE_TEXT,
        HbEnums.RELEASE
      );
    }
  }

  private handleTVAmountInput(req: HBussdReq, state: SessionState) {
    const amount = parseFloat(req.Message);
    if (isNaN(amount) || amount <= 0) {
      return this.createResponse(
        req.SessionId,
        "Invalid Amount",
        "Please enter a valid amount:",
        HbEnums.DATATYPE_INPUT,
        HbEnums.FIELDTYPE_DECIMAL,
        HbEnums.RESPONSE
      );
    }

    // Validate amount format (2 decimal places)
    const decimalPlaces = (amount.toString().split('.')[1] || '').length;
    if (decimalPlaces > 2) {
      return this.createResponse(
        req.SessionId,
        "Invalid Amount",
        "Amount must be in cedis (e.g., 10 or 10.50):",
        HbEnums.DATATYPE_INPUT,
        HbEnums.FIELDTYPE_DECIMAL,
        HbEnums.RESPONSE
      );
    }

    state.amount = amount;
    state.totalAmount = amount;
    this.sessionMap.set(req.SessionId, state);

    const accountDisplay = this.tvBillsService.formatAccountInfo(state.accountInfo);

    return this.createResponse(
      req.SessionId,
      "Confirm Payment",
      `${accountDisplay}\nAmount: GHS ${amount.toFixed(2)}\n\n1. Confirm\n2. Cancel`,
      HbEnums.DATATYPE_INPUT,
      HbEnums.FIELDTYPE_NUMBER,
      HbEnums.RESPONSE
    );
  }

  private async handleBundleQuery(req: HBussdReq, state: SessionState) {
    try {
      // Validate and convert mobile number format
      const mobileValidation = this.utilityService.validateAndConvertMobileNumber(req.Message);
      if (!mobileValidation.isValid) {
        return this.createResponse(
          req.SessionId,
          "Invalid Mobile Number",
          `Please enter a valid mobile number (e.g. 0550982043): ${mobileValidation.error}`,
          HbEnums.DATATYPE_INPUT,
          HbEnums.FIELDTYPE_PHONE,
          HbEnums.RESPONSE
        );
      }

      // Query bundles from Hubtel using converted number
      const bundleResponse = await this.bundleService.queryBundles({
        destination: mobileValidation.convertedNumber,
        network: state.network
      });

      if (bundleResponse.ResponseCode !== '0000') {
        return this.createResponse(
          req.SessionId,
          "Error",
          `Failed to fetch bundles: ${bundleResponse.Message}`,
          HbEnums.DATATYPE_DISPLAY,
          HbEnums.FIELDTYPE_TEXT,
          HbEnums.RELEASE
        );
      }

      // Store bundles and converted mobile number in session
      state.bundles = bundleResponse.Data;
      state.mobile = mobileValidation.convertedNumber;
      state.currentBundlePage = 1;
      this.sessionMap.set(req.SessionId, state);

      // Display first page of bundles
      return this.displayBundlePage(req.SessionId, state);
    } catch (error) {
      console.error('Error querying bundles:', error);
      return this.createResponse(
        req.SessionId,
        "Error",
        "Failed to fetch available bundles. Please try again.",
        HbEnums.DATATYPE_DISPLAY,
        HbEnums.FIELDTYPE_TEXT,
        HbEnums.RELEASE
      );
    }
  }

  private async showNetworkBundles(sessionId: string, state: SessionState) {
    try {
      // Get available bundles for the selected network using a sample number
      // In a real implementation, you would get the user's number from the session
      const sampleNumber = this.getSampleNumberForNetwork(state.network);
      const availableBundles = await this.bundleService.getAvailableBundles(
        state.network,
        sampleNumber,
        'data'
      );

      if (!availableBundles || availableBundles.length === 0) {
        return this.createResponse(
          sessionId,
          "No Bundles Available",
          "No bundles available for this network at the moment. Please try another network.",
          HbEnums.DATATYPE_DISPLAY,
          HbEnums.FIELDTYPE_TEXT,
          HbEnums.RELEASE
        );
      }

      // Store bundles and set initial page
      state.bundles = availableBundles;
      state.currentBundlePage = 1;
      this.sessionMap.set(sessionId, state);

      // Display first page of bundles
      return this.displayBundlePage(sessionId, state);
    } catch (error) {
      console.error('Error fetching available bundles:', error);
      return this.createResponse(
        sessionId,
        "Error",
        "Failed to fetch available bundles. Please try again.",
        HbEnums.DATATYPE_DISPLAY,
        HbEnums.FIELDTYPE_TEXT,
        HbEnums.RELEASE
      );
    }
  }

  private getSampleNumberForNetwork(network: string): string {
    // Sample numbers for each network - these should be replaced with actual user numbers
    const sampleNumbers = {
      'MTN': '233246912184',
      'Telecel Ghana': '233206439599',
      'AT': '233574126849'
    };
    return sampleNumbers[network] || '233246912184';
  }



  private displayBundlePage(sessionId: string, state: SessionState) {
    console.log(`Displaying bundle page - Session: ${sessionId}, Page: ${state.currentBundlePage}, Total Bundles: ${state.bundles?.length}`);

    if (!state.bundles || state.bundles.length === 0) {
      console.log('No bundles available for display');
      return this.createResponse(
        sessionId,
        "No Bundles",
        "No bundles available for this number. Please try another number.",
        HbEnums.DATATYPE_DISPLAY,
        HbEnums.FIELDTYPE_TEXT,
        HbEnums.RELEASE
      );
    }

    const pagination = this.bundleService.paginateBundles(state.bundles, state.currentBundlePage, 4);
    console.log(`Pagination info - Current: ${pagination.currentPage}, Total: ${pagination.totalPages}, Items: ${pagination.items.length}, HasNext: ${pagination.hasNext}`);
    const bundleOptions = pagination.items.map((bundle, index) =>
      this.bundleService.formatBundleDisplay(bundle, index)
    ).join('\n');

    // Create navigation options
    let navigationOptions = '';

    if (pagination.hasNext) {
      navigationOptions += '\n#. Next';
    }
    navigationOptions += '\n0. Back';

    const message = `Available Bundles:\n${bundleOptions}${navigationOptions}`;

    return this.createResponse(
      sessionId,
      "Select Bundle",
      message,
      HbEnums.DATATYPE_INPUT,
      HbEnums.FIELDTYPE_NUMBER,
      HbEnums.RESPONSE
    );
  }

  private handleBundleSelection(req: HBussdReq, state: SessionState) {
    const selection = req.Message;

    // Debug logging
    console.log(`Bundle Selection - Session: ${req.SessionId}, Selection: ${selection}, Current Page: ${state.currentBundlePage}, Total Bundles: ${state.bundles?.length}`);

    // Ensure bundles and currentBundlePage are set
    if (!state.bundles || state.bundles.length === 0) {
      console.log('No bundles found in state, redirecting to network selection');
      state.serviceType = "data_bundle";
      this.sessionMap.set(req.SessionId, state);
      return this.createResponse(
        req.SessionId,
        "Select Network",
        "Select Network:\n1. MTN\n2. Telecel Ghana\n3. AT",
        HbEnums.DATATYPE_INPUT,
        HbEnums.FIELDTYPE_NUMBER,
        HbEnums.RESPONSE
      );
    }

    if (!state.currentBundlePage) {
      state.currentBundlePage = 1;
      this.sessionMap.set(req.SessionId, state);
    }

    // Get pagination info for navigation and selection
    const pagination = this.bundleService.paginateBundles(state.bundles, state.currentBundlePage, 4);

    // Handle navigation - Next page
    if (selection === "#" && pagination.hasNext) {
      console.log(`Moving to next page: ${state.currentBundlePage} -> ${state.currentBundlePage + 1}`);
      state.currentBundlePage++;
      this.sessionMap.set(req.SessionId, state);
      return this.displayBundlePage(req.SessionId, state);
    }



    // Handle back to network selection
    if (selection === "0") {
      state.serviceType = "data_bundle";
      state.bundles = undefined;
      state.currentBundlePage = undefined;
      this.sessionMap.set(req.SessionId, state);
      return this.createResponse(
        req.SessionId,
        "Select Network",
        "Select Network:\n1. MTN\n2. Telecel Ghana\n3. AT",
        HbEnums.DATATYPE_INPUT,
        HbEnums.FIELDTYPE_NUMBER,
        HbEnums.RESPONSE
      );
    }

    // Handle bundle selection
    const selectedIndex = parseInt(selection) - 1;

    if (isNaN(selectedIndex) || selectedIndex < 0 || selectedIndex >= pagination.items.length) {
      let errorMessage = `Please select a valid bundle option (1-${pagination.items.length})`;

      if (pagination.hasNext) {
        errorMessage += ', # for Next';
      }
      errorMessage += ', or 0 to go Back:';

      return this.createResponse(
        req.SessionId,
        "Invalid Selection",
        errorMessage,
        HbEnums.DATATYPE_INPUT,
        HbEnums.FIELDTYPE_NUMBER,
        HbEnums.RESPONSE
      );
    }

    const selectedBundle = pagination.items[selectedIndex];
    state.selectedBundle = selectedBundle;
    state.bundleValue = selectedBundle.Value;
    state.totalAmount = selectedBundle.Amount;
    this.sessionMap.set(req.SessionId, state);

    return this.createResponse(
      req.SessionId,
      "Enter Mobile Number",
      "Enter mobile number to purchase bundle (e.g., 0550982043):",
      HbEnums.DATATYPE_INPUT,
      HbEnums.FIELDTYPE_PHONE,
      HbEnums.RESPONSE
    );
  }

  private handleBundleMobileNumber(req: HBussdReq, state: SessionState) {
    // Validate and convert mobile number format
    const mobileValidation = this.utilityService.validateAndConvertMobileNumber(req.Message);
    if (!mobileValidation.isValid) {
      return this.createResponse(
        req.SessionId,
        "Invalid Mobile Number",
        `Please enter a valid mobile number (e.g., 0550982043): ${mobileValidation.error}`,
        HbEnums.DATATYPE_INPUT,
        HbEnums.FIELDTYPE_PHONE,
        HbEnums.RESPONSE
      );
    }

    state.mobile = mobileValidation.convertedNumber;
    this.sessionMap.set(req.SessionId, state);

    return this.createResponse(
      req.SessionId,
      "Confirm Purchase",
      `Bundle: ${state.selectedBundle.Display}\nAmount: GHS ${state.selectedBundle.Amount.toFixed(2)}\nRecipient: ${state.mobile}\n\n1. Confirm\n2. Cancel`,
      HbEnums.DATATYPE_INPUT,
      HbEnums.FIELDTYPE_NUMBER,
      HbEnums.RESPONSE
    );
  }

  private handleAirtimeMobileNumber(req: HBussdReq, state: SessionState) {
    // Validate and convert mobile number format
    const mobileValidation = this.utilityService.validateAndConvertMobileNumber(req.Message);
    if (!mobileValidation.isValid) {
      return this.createResponse(
        req.SessionId,
        "Invalid Mobile Number",
        `Please enter a valid mobile number (e.g., 0550982043): ${mobileValidation.error}`,
        HbEnums.DATATYPE_INPUT,
        HbEnums.FIELDTYPE_PHONE,
        HbEnums.RESPONSE
      );
    }

    state.mobile = mobileValidation.convertedNumber;
    this.sessionMap.set(req.SessionId, state);

    return this.createResponse(
      req.SessionId,
      "Enter Amount",
      "Enter airtime amount (0.01-100):",
      HbEnums.DATATYPE_INPUT,
      HbEnums.FIELDTYPE_DECIMAL,
      HbEnums.RESPONSE
    );
  }

  private handleMobileNumber(req: HBussdReq, state: SessionState) {
    // Validate and convert mobile number format
    const mobileValidation = this.utilityService.validateAndConvertMobileNumber(req.Message);
    if (!mobileValidation.isValid) {
      return this.createResponse(
        req.SessionId,
        "Invalid Mobile Number",
        `Please enter a valid mobile number (e.g., 0550982034): ${mobileValidation.error}`,
        HbEnums.DATATYPE_INPUT,
        HbEnums.FIELDTYPE_PHONE,
        HbEnums.RESPONSE
      );
    }

    state.mobile = mobileValidation.convertedNumber;
    this.sessionMap.set(req.SessionId, state);
    return this.createResponse(
      req.SessionId,
      "Enter Name",
      "Enter recipient's name:",
      HbEnums.DATATYPE_INPUT,
      HbEnums.FIELDTYPE_TEXT,
      HbEnums.RESPONSE
    );
  }

  private handleNameInput(req: HBussdReq, state: SessionState) {
    if (!req.Message || req.Message.trim().length < 2) {
      return this.createResponse(
        req.SessionId,
        "Invalid Name",
        "Please enter a valid name (minimum 2 characters):",
        HbEnums.DATATYPE_INPUT,
        HbEnums.FIELDTYPE_TEXT,
        HbEnums.RESPONSE
      );
    }

    state.name = req.Message.trim();
    this.sessionMap.set(req.SessionId, state);
    return this.createResponse(
      req.SessionId,
      "Enter Quantity",
      "How many vouchers do you want to buy?",
      HbEnums.DATATYPE_INPUT,
      HbEnums.FIELDTYPE_NUMBER,
      HbEnums.RESPONSE
    );
  }

  private handleQuantityInput(req: HBussdReq, state: SessionState) {
    const quantity = parseInt(req.Message);
    if (isNaN(quantity) || quantity <= 0 || quantity > 100) {
      return this.createResponse(
        req.SessionId,
        "Invalid Quantity",
        "Please enter a valid quantity (1-100):",
        HbEnums.DATATYPE_INPUT,
        HbEnums.FIELDTYPE_NUMBER,
        HbEnums.RESPONSE
      );
    }

    state.quantity = quantity;
    state.totalAmount = this.getServicePrice(state.service) * quantity;
    this.sessionMap.set(req.SessionId, state);

    // Determine which mobile number to display based on flow
    // For airtime, always use the dialer's mobile number since there's no "self" vs "other" flow
    const displayMobile = state.serviceType === "airtime_topup" ? req.Mobile : (state.flow === "self" ? req.Mobile : (state.mobile || req.Mobile));

    return this.createResponse(
      req.SessionId,
      "Order Details",
      `Service: ${state.service}\nBought For: ${displayMobile}\nQuantity: ${quantity}\nAmount: GHS ${state.totalAmount.toFixed(2)}\n\n1. Confirm\n2. Cancel`,
      HbEnums.DATATYPE_INPUT,
      HbEnums.FIELDTYPE_NUMBER,
      HbEnums.RESPONSE
    );
  }

  private handleAmountInput(req: HBussdReq, state: SessionState) {
    const amount = parseFloat(req.Message);
    if (isNaN(amount) || amount <= 0 || amount > 100) {
      return this.createResponse(
        req.SessionId,
        "Invalid Amount",
        "Please enter a valid amount (0.01-100):",
        HbEnums.DATATYPE_INPUT,
        HbEnums.FIELDTYPE_DECIMAL,
        HbEnums.RESPONSE
      );
    }

    // Validate amount format (2 decimal places)
    const decimalPlaces = (amount.toString().split('.')[1] || '').length;
    if (decimalPlaces > 2) {
      return this.createResponse(
        req.SessionId,
        "Invalid Amount",
        "Amount must be in cedis (e.g., 10 or 10.50):",
        HbEnums.DATATYPE_INPUT,
        HbEnums.FIELDTYPE_DECIMAL,
        HbEnums.RESPONSE
      );
    }

    state.amount = amount;
    state.totalAmount = amount;
    this.sessionMap.set(req.SessionId, state);

    // Determine which mobile number to display based on flow
    const displayMobile = state.serviceType === "airtime_topup" ? (state.mobile || req.Mobile) : (state.flow === "self" ? req.Mobile : (state.mobile || req.Mobile));

    return this.createResponse(
      req.SessionId,
      "Order Details",
      `Service: Airtime Top-Up\nNetwork: ${state.network}\nRecipient: ${displayMobile}\nAmount: GHS ${amount.toFixed(2)}\n\n1. Confirm\n2. Cancel`,
      HbEnums.DATATYPE_INPUT,
      HbEnums.FIELDTYPE_NUMBER,
      HbEnums.RESPONSE
    );
  }

  private handleOrderDetails(req: HBussdReq, state: SessionState) {
    // For data bundles, ensure a bundle is selected
    if (state.serviceType === "data_bundle" && !state.selectedBundle) {
      return this.createResponse(
        req.SessionId,
        "No Bundle Selected",
        "Please select a bundle first before proceeding.",
        HbEnums.DATATYPE_DISPLAY,
        HbEnums.FIELDTYPE_TEXT,
        HbEnums.RELEASE
      );
    }

    if (req.Message === "1") {
      return this.handlePaymentConfirmation(req, state);
    } else if (req.Message === "2") {
      return this.releaseSession(req.SessionId);
    } else {
      return this.createResponse(
        req.SessionId,
        "Invalid Selection",
        "Please select 1 or 2",
        HbEnums.DATATYPE_INPUT,
        HbEnums.FIELDTYPE_NUMBER,
        HbEnums.RESPONSE
      );
    }
  }

  private async handlePaymentConfirmation(req: HBussdReq, state: SessionState) {
    if (req.Message !== "1") return this.releaseSession(req.SessionId);

    const total = state.totalAmount;

    try {
      if (state.serviceType === "result_checker") {
        // Store order details for later voucher assignment
        state.totalAmount = total;
        this.sessionMap.set(req.SessionId, state);
      } else if (state.serviceType === "data_bundle") {
        // Store order details for bundle processing
        state.totalAmount = total;
        this.sessionMap.set(req.SessionId, state);
      } else if (state.serviceType === "airtime_topup") {
        // Store order details for airtime processing
        state.totalAmount = total;
        this.sessionMap.set(req.SessionId, state);
      } else if (state.serviceType === "pay_bills") {
        // Store order details for TV bill processing
        state.totalAmount = total;
        this.sessionMap.set(req.SessionId, state);
      }
    } catch (error) {
      console.error("Error storing order details:", error);
      return this.createResponse(
        req.SessionId,
        "Error",
        "Unable to process request. Please try again.",
        HbEnums.DATATYPE_DISPLAY,
        HbEnums.FIELDTYPE_TEXT,
        HbEnums.RELEASE
      );
    }

    // AddToCart automatically triggers payment without showing reply prompts
    const response: any = {
      SessionId: req.SessionId,
      Type: HbEnums.ADDTOCART,
      Message: `Payment request for GHS ${total} has been submitted. Kindly approve the MOMO prompt. If no prompt, Dial *170# select 6) My Wallet 3) My Approvals`,
      Item: new CheckOutItem(state.service || state.selectedBundle?.Display || state.tvProvider || "Airtime Top-Up", 1, total),
      Label: "Payment Request Submitted",
      DataType: HbEnums.DATATYPE_DISPLAY,
      FieldType: HbEnums.FIELDTYPE_TEXT
    };
    // AddToCart type automatically prevents user input and triggers payment flow
    return JSON.stringify(response);
  }

  private async releaseSession(sessionId: string) {
    // Log session completion
    await this.updateUssdLog(sessionId, 'completed');

    // Clean up session state
    this.sessionMap.delete(sessionId);
    return this.createResponse(
      sessionId,
      "Thank you",
      "Love from Guglex Technologies",
      HbEnums.DATATYPE_DISPLAY,
      HbEnums.FIELDTYPE_TEXT,
      HbEnums.RELEASE
    );
  }

  private createResponse(
    sessionId: string,
    label: string,
    message: string,
    dataType: string,
    fieldType: string = HbEnums.FIELDTYPE_TEXT,
    type: string = HbEnums.RESPONSE
  ) {
    return JSON.stringify({
      SessionId: sessionId,
      Type: type,
      Label: label,
      Message: message,
      DataType: dataType,
      FieldType: fieldType
    });
  }

  async handleUssdCallback(req: HbPayments) {
    console.error("LOGGING CALLBACK::::::", req);

    if (!req.OrderInfo || !req.OrderInfo.Payment) return;

    let finalResponse = new FinalUssdReq();
    finalResponse.SessionId = req.SessionId;
    finalResponse.OrderId = req.OrderId;
    finalResponse.MetaData = null;

    const transaction = new this.transactionModel({
      SessionId: req.SessionId,
      OrderId: req.OrderId,
      ExtraData: req.ExtraData,
      CustomerMobileNumber: req.OrderInfo.CustomerMobileNumber,
      CustomerEmail: req.OrderInfo.CustomerEmail,
      CustomerName: req.OrderInfo.CustomerName,
      Status: req.OrderInfo.Status,
      OrderDate: req.OrderInfo.OrderDate,
      Currency: req.OrderInfo.Currency,
      BranchName: req.OrderInfo.BranchName,
      IsRecurring: req.OrderInfo.IsRecurring,
      RecurringInvoiceId: req.OrderInfo.RecurringInvoiceId,
      Subtotal: req.OrderInfo.Subtotal,
      Items: req.OrderInfo.Items,
      PaymentType: req.OrderInfo.Payment.PaymentType,
      AmountPaid: req.OrderInfo.Payment.AmountPaid,
      AmountAfterCharges: req.OrderInfo.Payment.AmountAfterCharges,
      PaymentDate: req.OrderInfo.Payment.PaymentDate,
      PaymentDescription: req.OrderInfo.Payment.PaymentDescription,
      IsSuccessful: req.OrderInfo.Payment.IsSuccessful
    });

    await transaction.save();

    try {
      const isSuccessful = req.OrderInfo.Payment.IsSuccessful;

      // Log payment completion
      await this.updateUssdLog(req.SessionId, isSuccessful ? 'completed' : 'failed', {
        paymentStatus: req.OrderInfo.Status,
        orderId: req.OrderId,
        amountPaid: req.OrderInfo.Payment.AmountPaid,
        isSuccessful: isSuccessful
      });

      if (isSuccessful) {
        finalResponse.ServiceStatus = "success";

        // Get the session state to process after successful payment
        const sessionState = this.sessionMap.get(req.SessionId);
        if (sessionState) {
          // Process commission service for all service types
          try {
            await this.processCommissionServiceAfterPayment(sessionState, req.SessionId, req.OrderInfo);
          } catch (error) {
            console.error("Error processing commission service after payment:", error);
          }
        }

        await this.hbPaymentsModel.findOneAndUpdate(
          { SessionId: req.SessionId },
          { $set: { SessionId: req.SessionId, OrderId: req.OrderId } },
          { upsert: true, new: true }
        );
      } else {
        finalResponse.ServiceStatus = "failed";
      }

      await axios.post(`${process.env.HB_CALLBACK_URL}`, finalResponse, {
        headers: {
          "Content-Type": "application/json",
          Authorization: `Basic ${process.env.HUB_ACCESS_TOKEN}`
        }
      });
    } catch (error) {
      console.error("Error processing USSD callback:", error);
    }
  }

  /**
   * Process commission service after successful payment
   * This handles all service types through the commission service
   */
  private async processCommissionServiceAfterPayment(sessionState: SessionState, sessionId: string, orderInfo: any) {
    try {
      if (sessionState.serviceType === "result_checker") {
        // Handle voucher assignment (not a commission service)
        const purchaseResult = await this.vouchersService.purchaseVouchers({
          quantity: sessionState.quantity,
          mobile_number: orderInfo.CustomerMobileNumber,
          name: sessionState.flow === "self" ? orderInfo.CustomerMobileNumber : sessionState.name,
          flow: sessionState.flow,
          bought_for_mobile: sessionState.flow === "other" ? sessionState.mobile : orderInfo.CustomerMobileNumber,
          bought_for_name: sessionState.flow === "other" ? sessionState.name : orderInfo.CustomerMobileNumber
        });

        // Send SMS with all assigned voucher details
        await sendVoucherSms({
          mobile: sessionState.flow === "self" ? orderInfo.CustomerMobileNumber : sessionState.mobile,
          name: orderInfo.CustomerName,
          vouchers: purchaseResult.assigned_vouchers,
          flow: sessionState.flow,
          buyer_name: sessionState.flow === "other" ? orderInfo.CustomerName : undefined,
          buyer_mobile: sessionState.flow === "other" ? orderInfo.CustomerMobileNumber : undefined
        });

        // Update the assigned vouchers to mark them as sold and successful
        await this.voucherModel.updateMany(
          { serial_number: { $in: purchaseResult.assigned_vouchers.map(v => v.serial_number) } },
          {
            $set: {
              sold: true,
              isSuccessful: true,
              paymentStatus: orderInfo.Status
            }
          }
        );
      } else {
        // Handle commission services
        const commissionRequest = this.buildCommissionServiceRequest(sessionState, sessionId);
        if (commissionRequest) {
          await this.commissionService.processCommissionService(commissionRequest);
        }
      }
    } catch (error) {
      console.error("Error processing commission service after payment:", error);
      throw error;
    }
  }

  /**
   * Build commission service request based on session state
   */
  private buildCommissionServiceRequest(sessionState: SessionState, sessionId: string) {
    const baseRequest = {
      clientReference: sessionId,
      amount: sessionState.totalAmount,
      callbackUrl: `${process.env.HB_CALLBACK_URL}`
    };

    switch (sessionState.serviceType) {
      case "data_bundle":
        return {
          ...baseRequest,
          serviceType: 'bundle' as const,
          network: sessionState.network,
          destination: sessionState.mobile,
          extraData: {
            bundleType: 'data',
            bundleValue: sessionState.bundleValue
          }
        };

      case "airtime_topup":
        return {
          ...baseRequest,
          serviceType: 'airtime' as const,
          network: sessionState.network,
          destination: sessionState.mobile,
          extraData: {}
        };

      case "pay_bills":
        return {
          ...baseRequest,
          serviceType: 'tv_bill' as const,
          tvProvider: sessionState.tvProvider,
          destination: sessionState.accountNumber,
          extraData: {
            accountNumber: sessionState.accountNumber
          }
        };

      case "utility_service":
        if (sessionState.utilityProvider === UtilityProvider.ECG) {
          return {
            ...baseRequest,
            serviceType: 'utility' as const,
            utilityProvider: sessionState.utilityProvider,
            destination: sessionState.mobile,
            extraData: {
              meterNumber: sessionState.meterNumber
            }
          };
        } else if (sessionState.utilityProvider === UtilityProvider.GHANA_WATER) {
          return {
            ...baseRequest,
            serviceType: 'utility' as const,
            utilityProvider: sessionState.utilityProvider,
            destination: sessionState.meterNumber,
            extraData: {
              meterNumber: sessionState.meterNumber,
              email: sessionState.email,
              sessionId: sessionId
            }
          };
        }
        return null;

      default:
        return null;
    }
  }

  private async handleUtilityQuery(req: HBussdReq, state: SessionState) {
    try {
      if (state.utilityProvider === UtilityProvider.ECG) {
        // Validate and convert mobile number format
        const mobileValidation = this.utilityService.validateAndConvertMobileNumber(req.Message);
        if (!mobileValidation.isValid) {
          return this.createResponse(
            req.SessionId,
            "Invalid Mobile Number",
            `Please enter a valid mobile number (e.g., 0550982043): ${mobileValidation.error}`,
            HbEnums.DATATYPE_INPUT,
            HbEnums.FIELDTYPE_PHONE,
            HbEnums.RESPONSE
          );
        }

        // Query ECG meters from Hubtel using converted number
        const meterResponse = await this.utilityService.queryECGMeters({
          mobileNumber: mobileValidation.convertedNumber
        });

        if (meterResponse.ResponseCode !== '0000') {
          return this.createResponse(
            req.SessionId,
            "Error",
            `Failed to fetch meters: ${meterResponse.Message}`,
            HbEnums.DATATYPE_DISPLAY,
            HbEnums.FIELDTYPE_TEXT,
            HbEnums.RELEASE
          );
        }

        // Store meter info and converted mobile number in session
        state.meterInfo = meterResponse.Data;
        state.mobile = mobileValidation.convertedNumber;
        this.sessionMap.set(req.SessionId, state);

        // Display meter information
        const meterDisplay = this.utilityService.formatECGMeterInfo(meterResponse.Data);

        return this.createResponse(
          req.SessionId,
          "Select Meter",
          `${meterDisplay}\n\nSelect meter number:`,
          HbEnums.DATATYPE_INPUT,
          HbEnums.FIELDTYPE_TEXT,
          HbEnums.RESPONSE
        );
      } else {
        // Ghana Water - validate meter number format
        if (!this.utilityService.validateGhanaWaterMeterNumber(req.Message)) {
          return this.createResponse(
            req.SessionId,
            "Invalid Meter Number",
            "Please enter a valid 12-digit meter number:",
            HbEnums.DATATYPE_INPUT,
            HbEnums.FIELDTYPE_TEXT,
            HbEnums.RESPONSE
          );
        }

        state.meterNumber = req.Message;
        this.sessionMap.set(req.SessionId, state);

        return this.createResponse(
          req.SessionId,
          "Enter Mobile Number",
          "Enter mobile number for Ghana Water (e.g., 0550982043):",
          HbEnums.DATATYPE_INPUT,
          HbEnums.FIELDTYPE_PHONE,
          HbEnums.RESPONSE
        );
      }
    } catch (error) {
      console.error('Error querying utility:', error);
      return this.createResponse(
        req.SessionId,
        "Error",
        "Failed to fetch information. Please try again.",
        HbEnums.DATATYPE_DISPLAY,
        HbEnums.FIELDTYPE_TEXT,
        HbEnums.RELEASE
      );
    }
  }

  private async handleUtilityStep5(req: HBussdReq, state: SessionState) {
    if (state.utilityProvider === UtilityProvider.ECG) {
      // Handle ECG meter selection
      const selectedIndex = parseInt(req.Message) - 1;

      if (isNaN(selectedIndex) || selectedIndex < 0 || selectedIndex >= (state.meterInfo?.length || 0)) {
        return this.createResponse(
          req.SessionId,
          "Invalid Selection",
          "Please select a valid meter option:",
          HbEnums.DATATYPE_INPUT,
          HbEnums.FIELDTYPE_NUMBER,
          HbEnums.RESPONSE
        );
      }

      const selectedMeter = state.meterInfo[selectedIndex];
      state.meterNumber = selectedMeter.Value.trim();
      this.sessionMap.set(req.SessionId, state);

      return this.createResponse(
        req.SessionId,
        "Enter Amount",
        "Enter top-up amount:",
        HbEnums.DATATYPE_INPUT,
        HbEnums.FIELDTYPE_DECIMAL,
        HbEnums.RESPONSE
      );
    } else {
      // Ghana Water - validate mobile number and query account
      const mobileValidation = this.utilityService.validateAndConvertMobileNumber(req.Message);
      if (!mobileValidation.isValid) {
        return this.createResponse(
          req.SessionId,
          "Invalid Mobile Number",
          `Please enter a valid mobile number (e.g., 0550982043): ${mobileValidation.error}`,
          HbEnums.DATATYPE_INPUT,
          HbEnums.FIELDTYPE_PHONE,
          HbEnums.RESPONSE
        );
      }

      try {
        const accountResponse = await this.utilityService.queryGhanaWaterAccount({
          meterNumber: state.meterNumber,
          mobileNumber: mobileValidation.convertedNumber
        });

        if (accountResponse.ResponseCode !== '0000') {
          return this.createResponse(
            req.SessionId,
            "Error",
            `Failed to fetch account: ${accountResponse.Message}`,
            HbEnums.DATATYPE_DISPLAY,
            HbEnums.FIELDTYPE_TEXT,
            HbEnums.RELEASE
          );
        }

        // Store account info and converted mobile number in session
        state.meterInfo = accountResponse.Data;
        state.mobile = mobileValidation.convertedNumber;
        this.sessionMap.set(req.SessionId, state);

        // Display account information
        const accountDisplay = this.utilityService.formatGhanaWaterInfo(accountResponse.Data);

        return this.createResponse(
          req.SessionId,
          "Account Information",
          `${accountDisplay}\n\nEnter payment amount:`,
          HbEnums.DATATYPE_INPUT,
          HbEnums.FIELDTYPE_DECIMAL,
          HbEnums.RESPONSE
        );
      } catch (error) {
        console.error('Error querying Ghana Water account:', error);
        return this.createResponse(
          req.SessionId,
          "Error",
          "Failed to fetch account information. Please try again.",
          HbEnums.DATATYPE_DISPLAY,
          HbEnums.FIELDTYPE_TEXT,
          HbEnums.RELEASE
        );
      }
    }
  }

  private handleUtilityAmountInput(req: HBussdReq, state: SessionState) {
    const amount = parseFloat(req.Message);
    if (isNaN(amount) || amount <= 0) {
      return this.createResponse(
        req.SessionId,
        "Invalid Amount",
        "Please enter a valid amount:",
        HbEnums.DATATYPE_INPUT,
        HbEnums.FIELDTYPE_DECIMAL,
        HbEnums.RESPONSE
      );
    }

    // Validate amount format (2 decimal places)
    const decimalPlaces = (amount.toString().split('.')[1] || '').length;
    if (decimalPlaces > 2) {
      return this.createResponse(
        req.SessionId,
        "Invalid Amount",
        "Amount must be in cedis (e.g., 10 or 10.50):",
        HbEnums.DATATYPE_INPUT,
        HbEnums.FIELDTYPE_DECIMAL,
        HbEnums.RESPONSE
      );
    }

    state.amount = amount;
    state.totalAmount = amount;
    this.sessionMap.set(req.SessionId, state);

    if (state.utilityProvider === UtilityProvider.ECG) {
      const meterDisplay = this.utilityService.formatECGMeterInfo(state.meterInfo);
      const selectedMeter = state.meterInfo.find(m => m.Value.trim() === state.meterNumber);

      return this.createResponse(
        req.SessionId,
        "Confirm ECG Top-Up",
        `Meter: ${selectedMeter?.Display.trim()}\nAmount: GHS ${amount.toFixed(2)}\n\n1. Confirm\n2. Cancel`,
        HbEnums.DATATYPE_INPUT,
        HbEnums.FIELDTYPE_NUMBER,
        HbEnums.RESPONSE
      );
    } else {
      const accountDisplay = this.utilityService.formatGhanaWaterInfo(state.meterInfo);

      return this.createResponse(
        req.SessionId,
        "Confirm Ghana Water Payment",
        `${accountDisplay}\nAmount: GHS ${amount.toFixed(2)}\n\n1. Confirm\n2. Cancel`,
        HbEnums.DATATYPE_INPUT,
        HbEnums.FIELDTYPE_NUMBER,
        HbEnums.RESPONSE
      );
    }
  }

  private getServicePrice(service: string): number {
    // Price mapping for different services
    const priceMap = {
      "BECE Checker Voucher": 20,
      "NovDec Checker": 21,
      "School Placement Checker": 21,
      "Data Bundle": 21,
      "Voice Bundle": 21,
      "ECG Prepaid": 21
    };

    return priceMap[service] || 21;
  }

  /**
   * Check transaction status for USSD transactions
   */
  async checkUssdTransactionStatus(clientReference: string): Promise<any> {
    try {
      const statusResponse = await this.transactionStatusService.checkStatusByClientReference(clientReference);
      const summary = this.transactionStatusService.getTransactionStatusSummary(statusResponse);

      return {
        success: true,
        data: statusResponse,
        summary: summary,
        isSuccessful: this.transactionStatusService.isTransactionSuccessful(statusResponse),
        shouldRetry: this.transactionStatusService.shouldRetryTransaction(statusResponse),
        formattedDetails: this.transactionStatusService.getFormattedTransactionDetails(statusResponse)
      };
    } catch (error) {
      console.error('Error checking USSD transaction status:', error);
      return {
        success: false,
        message: error.message || 'Failed to check transaction status',
        shouldRetry: true
      };
    }
  }

  /**
   * Handle transaction status check for pending transactions
   */
  async handlePendingTransactionStatusCheck(): Promise<void> {
    try {
      await this.transactionStatusService.checkPendingTransactions();
      console.log('Pending transaction status check completed');
    } catch (error) {
      console.error('Error in pending transaction status check:', error);
    }
  }

  /**
   * Log USSD interaction (upsert - update existing or create new)
   */
  private async logUssdInteraction(req: HBussdReq, state: SessionState, action: string = 'interaction') {
    try {
      const logData = {
        mobileNumber: req.Mobile,
        sessionId: req.SessionId,
        sequence: req.Sequence,
        message: req.Message,
        serviceType: state.serviceType,
        service: state.service,
        flow: state.flow,
        network: state.network,
        amount: state.amount,
        totalAmount: state.totalAmount,
        quantity: state.quantity,
        recipientName: state.name,
        recipientMobile: state.mobile,
        tvProvider: state.tvProvider,
        accountNumber: state.accountNumber,
        utilityProvider: state.utilityProvider,
        meterNumber: state.meterNumber,
        bundleValue: state.bundleValue,
        selectedBundle: state.selectedBundle,
        accountInfo: state.accountInfo,
        meterInfo: state.meterInfo,
        status: action,
        userAgent: 'USSD',
        deviceInfo: 'Mobile USSD',
        location: 'Ghana',
      };

      // Only set dialedAt for new records (initiated status)
      if (action === 'initiated') {
        logData['dialedAt'] = new Date();
      }

      // Use upsert to update existing record or create new one
      await this.ussdLogModel.findOneAndUpdate(
        { sessionId: req.SessionId },
        logData,
        { 
          upsert: true, 
          new: true,
          setDefaultsOnInsert: true
        }
      );
    } catch (error) {
      console.error('Error logging USSD interaction:', error);
    }
  }

  /**
   * Update USSD log with completion status
   */
  private async updateUssdLog(sessionId: string, status: string, additionalData: any = {}) {
    try {
      // Get existing record to calculate duration
      const existingLog = await this.ussdLogModel.findOne({ sessionId });
      
      const updateData = {
        status,
        completedAt: new Date(),
        ...additionalData
      };

      if (status === 'completed' && existingLog) {
        updateData.isSuccessful = true;
        updateData.duration = Math.floor((new Date().getTime() - existingLog.dialedAt.getTime()) / 1000);
      } else if (status === 'failed') {
        updateData.isSuccessful = false;
      }

      await this.ussdLogModel.findOneAndUpdate(
        { sessionId },
        { $set: updateData }, // Use $set to only update specific fields
        { 
          new: true,
          upsert: false // Don't create if doesn't exist, should already exist
        }
      );
    } catch (error) {
      console.error('Error updating USSD log:', error);
    }
  }

  /**
   * Get USSD logs by mobile number
   */
  async getUssdLogsByMobile(mobileNumber: string, limit: number = 50): Promise<UssdLog[]> {
    try {
      return await this.ussdLogModel
        .find({ mobileNumber })
        .sort({ dialedAt: -1 })
        .limit(limit)
        .exec();
    } catch (error) {
      console.error('Error fetching USSD logs:', error);
      return [];
    }
  }

  /**
   * Get USSD logs by session ID
   */
  async getUssdLogsBySession(sessionId: string): Promise<UssdLog[]> {
    try {
      return await this.ussdLogModel
        .find({ sessionId })
        .sort({ sequence: 1 })
        .exec();
    } catch (error) {
      console.error('Error fetching USSD logs by session:', error);
      return [];
    }
  }

  /**
   * Get USSD statistics
   */
  async getUssdStatistics(): Promise<any> {
    try {
      const totalDialers = await this.ussdLogModel.distinct('mobileNumber').countDocuments();
      const todayDialers = await this.ussdLogModel.countDocuments({
        dialedAt: { $gte: new Date(new Date().setHours(0, 0, 0, 0)) }
      });
      const completedTransactions = await this.ussdLogModel.countDocuments({ status: 'completed' });
      const failedTransactions = await this.ussdLogModel.countDocuments({ status: 'failed' });

      return {
        totalDialers,
        todayDialers,
        completedTransactions,
        failedTransactions,
        successRate: totalDialers > 0 ? (completedTransactions / totalDialers * 100).toFixed(2) : 0
      };
    } catch (error) {
      console.error('Error fetching USSD statistics:', error);
      return {};
    }
  }

  /**
   * Get all USSD logs with pagination
   */
  async getAllUssdLogs(page: number = 1, limit: number = 50, status?: string): Promise<any> {
    try {
      const skip = (page - 1) * limit;
      const filter: any = {};

      if (status) {
        filter.status = status;
      }

      const [logs, total] = await Promise.all([
        this.ussdLogModel
          .find(filter)
          .sort({ dialedAt: -1 })
          .skip(skip)
          .limit(limit)
          .exec(),
        this.ussdLogModel.countDocuments(filter)
      ]);

      return {
        logs,
        pagination: {
          page,
          limit,
          total,
          pages: Math.ceil(total / limit),
          hasNext: page * limit < total,
          hasPrev: page > 1
        }
      };
    } catch (error) {
      console.error('Error fetching all USSD logs:', error);
      return { logs: [], pagination: {} };
    }
  }
}
